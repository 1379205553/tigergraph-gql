## 深度优先
略

## 广度优先
略

## A*搜索
```
DFS和BFS在展开子结点时均属于盲目型搜索，也就是说，
它不会选择哪个结点在下一次搜索中更优而去跳转到该结点进行下一步的搜索。
在运气不好的情形中，均需要试探完整个解集空间, 显然，只能适用于问题规模不大的搜索问题中。

A*算法，作为启发式算法中很重要的一种，被广泛应用在最优路径求解和一些策略设计的问题中。
而A*算法最为核心的部分，就在于它的一个估值函数的设计上：
    f(n)=g(n)+h(n)
其中f(n)是每个可能试探点的估值，它有两部分组成：
一部分，为g(n)，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。
一部分，即h(n)，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值。
```

## K层展开
以一个节点作为起点，向周围扩展K次，每次都会向外扩展

## 最短路径
寻找两个节点之间的最短路径

### Dijkstra
```
属于广度优先，算法时间复杂度O（N^2）
Dijkstra 算法，又叫迪科斯彻算法（Dijkstra）,主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
算法解决的是有向图中单个源点到其他顶点的最短路径问题。
举例来说，如果图中的顶点表示城市，
而边上的权重表示著城市间开车行经的距离，Dijkstra 算法可以用来找到两个城市之间的最短路径。

Dijkstra无法判断含负权边的图的最短路。
```

### Bellman-Ford
```
松弛函数，时间复杂度O（VE）
对边集合 E 中任意边，以 w(u,v) 表示顶点 u 出发到顶点 v 的边的权值，
以 d[v] 表示当前从起点 s 到顶点 v 的路径权值

若存在边 w(u,v)，使得： d[v] \gt d[u]+w(u,v)
则更新 d[v] 值：d[v]=d[u]+w(u,v)
所以松弛函数的作用，就是判断是否经过某个顶点，或者说经过某条边，可以缩短起点到终点的路径权值。
```
```
Bellman-Ford 算法计算最短路径的过程中，使用了上述的松弛函数，通过对路径的不断松弛，来逐渐获取最短路径。
Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。
对于给定的带权（有向或无向）图 G=(V,E), 其源点为s，加权函数 w是 边集 E 的映射。
对图G运行Bellman - Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。
若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。
```

### Floyd-Warshall
```
弗洛伊德算法的时间复杂度为O(N^3)
Floyd-Warshall的原理是动态规划
设Di,j,k为从i到j的只以(1..k)集合中的节点为中间节点的最短路径的长度。
若最短路径经过点k，则Di,j,k = Di,k,k-1 + Dk,j,k-1；
若最短路径不经过点k，则Di,j,k = Di,j,k-1。
因此，Di,j,k = min(Di,k,k-1 + Dk,j,k-1 , Di,j,k-1)。
```

## 全路径
寻找两个节点之间的所有路径


## 社区发现
待续




# 其他图查询算法




