## 深度优先
略

## 广度优先
略

## A*搜索
```
DFS和BFS在展开子结点时均属于盲目型搜索，也就是说，
它不会选择哪个结点在下一次搜索中更优而去跳转到该结点进行下一步的搜索。
在运气不好的情形中，均需要试探完整个解集空间, 显然，只能适用于问题规模不大的搜索问题中。

A*算法，作为启发式算法中很重要的一种，被广泛应用在最优路径求解和一些策略设计的问题中。
而A*算法最为核心的部分，就在于它的一个估值函数的设计上：
    f(n)=g(n)+h(n)
其中f(n)是每个可能试探点的估值，它有两部分组成：
一部分，为g(n)，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。
一部分，即h(n)，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值。
```

## K层展开
以一个节点作为起点，向周围扩展K次，每次都会向外扩展

## 最短路径
寻找两个节点之间的最短路径。
寻找最短路径的算法有很多，其中SPFA是最快的算法了

### SPFA(Shortest Path Faster Algorithm)
```
SPFA算法是求单源最短路径的一种算法，它是对Bellman-ford优化的结果，关键在于通过动态逼近方法得到。
它是一种十分高效的最短路算法。

实现方法：建立一个队列，初始时队列里只有起始点s，
在建立一个数组记录起始点s到所有点的最短路径（初始值都要赋为极大值，该点到他本身的路径赋为0）.
然后执行松弛操作，用队列里的点去刷新起始点s到所有点的距离的距离，如果刷新成功且刷新的点不在队列中，
则把该点加入到队列，重复执行直到队列为空。
```

### Bellman-Ford
```
松弛函数，时间复杂度O（VE）
对边集合 E 中任意边，以 w(u,v) 表示顶点 u 出发到顶点 v 的边的权值，
以 d[v] 表示当前从起点 s 到顶点 v 的路径权值

若存在边 w(u,v)，使得： d[v] \gt d[u]+w(u,v)
则更新 d[v] 值：d[v]=d[u]+w(u,v)
所以松弛函数的作用，就是判断是否经过某个顶点，或者说经过某条边，可以缩短起点到终点的路径权值。
```

```
贝尔曼算法计算最短路径的过程中，使用了上述的松弛函数，通过对路径的不断松弛，来逐渐获取最短路径。
贝尔曼算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。
对于给定的带权（有向或无向）图 G=(V,E), 其源点为s，加权函数 w是 边集 E 的映射。
对图G运行Bellman - Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。
若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。
```

### Dijkstra
```
属于广度优先，算法时间复杂度O（N^2）
Dijkstra 算法，又叫迪科斯彻算法（Dijkstra）,主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
算法解决的是有向图中单个源点到其他顶点的最短路径问题。
举例来说，如果图中的顶点表示城市，
而边上的权重表示著城市间开车行经的距离，Dijkstra 算法可以用来找到两个城市之间的最短路径。

Dijkstra无法判断含负权边的图的最短路。
```

### Floyd-Warshall
```
弗洛伊德算法的时间复杂度为O(N^3)
Floyd-Warshall的原理是动态规划
设Di,j,k为从i到j的只以(1..k)集合中的节点为中间节点的最短路径的长度。
若最短路径经过点k，则Di,j,k = Di,k,k-1 + Dk,j,k-1；
若最短路径不经过点k，则Di,j,k = Di,j,k-1。
因此，Di,j,k = min(Di,k,k-1 + Dk,j,k-1 , Di,j,k-1)。
```

## 全路径
```
寻找两个节点之间的所有路径。
这个定义意味着寻找所有路径的过程要遍历所有关联顶点，否则怎么可能知道是否得到完整的路径列表呢？
所以这里几乎不需要算法，根据层数，展开K层后，在这个范围内寻找所有路径，否则默认会遍历全图。
```

## 社区发现
待续


# 其他图查询算法




